//
//  XCryptRequest.m
//  SyncHelper
//
//  Created by wjg on 13/11/2017.
//  Copyright © 2017 wjg All rights reserved.
//

#import "XCryptRequest.h"
#import "CategoriesHeader.h"

#define cryptReadSize (1024*1024*2)
#define Sender (@"sender")
#define CallbackParam (@"callbackParam")

#define OperationNone (9999)

// The error domain that all errors generated by XCryptRequest use
#define XCryptRequestErrorDomain (@"XCryptRequestErrorDomain")

@interface XCryptRequest(){

    //about crypt
    CCCryptorRef _cryptor;
    UInt8 _keyP[kCCKeySizeAES256],_ivP[kCCBlockSizeAES128];
    
    //about operation status
    BOOL cancelled;
    BOOL finished;
    BOOL ready;
    BOOL executing;
//    BOOL concurrent;
}

@property(nonatomic,strong)NSInputStream *readStream;//read stream
@property(nonatomic,strong)NSOutputStream *writeStream;//write strream

@property(nonatomic,readwrite,copy)NSString *desFilePath;//destination file path

@property(nonatomic,strong)NSFileManager *fm;//file manager

@property(nonatomic,readwrite,assign)fileSize_t fileSize;//source file size
@property(nonatomic,readwrite,assign)fileSize_t xcryptSize;//xcryp progress size

@property(nonatomic,readwrite,strong)NSError *er;//error info
@property(nonatomic,assign)XCryptErrorType erType;//error type

#pragma mark -
@property (atomic, strong) NSRecursiveLock *oplock;//operation lock,etc:cancel operation

@end

@implementation XCryptRequest
#pragma mark -
+(NSOperationQueue *)shareQueue{

    static NSOperationQueue *shareQueue;
    static dispatch_once_t onceToken;
    
    dispatch_once(&onceToken, ^{
        
        shareQueue=[[NSOperationQueue alloc] init];
        
        shareQueue.maxConcurrentOperationCount=NSOperationQueueDefaultMaxConcurrentOperationCount;
        shareQueue.suspended=NO;
    });
    
    return shareQueue;
}

-(instancetype)init{

    self=[super init];
    if(self){
    
        _cryptor=NULL;
        _fileSize=0.0;
        _xcryptSize=0.0;
        _operation=OperationNone;
        
        bzero(_keyP, sizeof(_keyP));
        bzero(_ivP, sizeof(_ivP));
        
        _oplock=[[NSRecursiveLock alloc] init];
        
        _er=nil;
        _erType=CryptNoneError;
        
        cancelled=NO;
        finished=NO;
        ready=NO;
        executing=NO;
        
    }
    
    return self;
}

#pragma mark - operation run logic
-(void)start{

    @try {
        
        //ready execute
        [self readyExecuting];
        if([self isCancelled] ||
           [self isFinished]){
            return;
        }
        
        //execute
        [self main];
        
    } @catch (NSException *exception) {
        
        NSError *er = [NSError errorWithDomain:XCryptRequestErrorDomain
                                          code:UnhandledExceptionError
                                      userInfo:[exception userInfo]];
        
        [self unexceptionError:er];
        
    } @finally {
        
        NSLog(@"finally");
    }
}

-(void)main{

    @try {
        
        if([self isCancelled] ||
           [self isFinished]){
            return;
        }
        
        [self aesCBCCrypt];
        
    } @catch (NSException *exception) {
        
        NSError *er = [NSError errorWithDomain:XCryptRequestErrorDomain
                                          code:UnhandledExceptionError
                                      userInfo:[exception userInfo]];
        
        [self unexceptionError:er];
        
    } @finally {
        
        NSLog(@"finally");
    }
}

-(void)cancel{
    
    [self.oplock lock];
    
    if([self isFinished] || [self isCancelled]){
        
        [self.oplock unlock];
        return;
    }
    
    [self willChangeValueForKey:@"isCancelled"];
    [self setCancelledStatus:YES];
    [self didChangeValueForKey:@"isCancelled"];
    
    self.erType=CancelledXCryptError;
    
    [self markAsFinished];
    
    [self.oplock unlock];
}

#pragma mark - ready execute logic
-(void)readyExecuting{

    [self setExecutingStatus:YES];
    
    //check and convert key,iv
    [self checkKeyAndIV];
    if([self isFinished]){
        return;
    }
    
    //check and create cryptor
    [self checkAndCreateCryptor];
    if([self isFinished]){
        return;
    }
    
    //check source file
    [self checkSourceFile];
    if([self isFinished]){
        return;
    }
    
    //check and create des file
    [self checkAndCreateDestinationFile];
    if([self isFinished]){
        return;
    }
    
    //check and create file stream
    [self checkAndCreateFileStream];
    if([self isFinished]){
        return;
    }
    
    //is ready
//    [self willChangeValueForKey:@"isReady"];
//    [self setReadyStatus:YES];
//    [self didChangeValueForKey:@"isReady"];
}

#pragma mark - check method
-(void)checkKeyAndIV{

    //create restrict raw key and iv
    BOOL keyConvertion=[self.key getBytes:_keyP maxLength:kCCKeySizeAES256 usedLength:NULL encoding:NSUTF8StringEncoding options:0 range:NSMakeRange(0, kCCKeySizeAES256) remainingRange:NULL];
    BOOL ivConvertion=[self.iv getBytes:_ivP maxLength:kCCBlockSizeAES128 usedLength:NULL encoding:NSUTF8StringEncoding options:0 range:NSMakeRange(0, kCCBlockSizeAES128) remainingRange:NULL];
    
    NSLog(@"key:%s",_keyP);
    NSLog(@"iv:%s",_ivP);
    NSLog(@"keyState:%d",keyConvertion);
    NSLog(@"ivState:%d",ivConvertion);
    
    //key or iv conversion occur error
    if(!keyConvertion || !ivConvertion){
        
        self.erType=KeyorIVConversionError;
        
        [self markAsFinished];
    }
}

-(void)checkAndCreateCryptor{

    BOOL creatingIsOk=YES;
    
    if(self.operation==OperationNone){
    
        creatingIsOk=NO;
    }
    
    // Create the cryptor
    if(creatingIsOk){
        
        CCCryptorStatus result;
        result = CCCryptorCreate(self.operation,         // operation
                                 kCCAlgorithmAES,       // algorithim
                                 kCCOptionPKCS7Padding, // options
                                 _keyP,              // key
                                 kCCKeySizeAES256,  // keylength
                                 _ivP,              // IV
                                 &_cryptor);        // OUT cryptorRef
        
        if (result != kCCSuccess || _cryptor == NULL){
            
            creatingIsOk=NO;
        }
    }
    
    
    if(!creatingIsOk){
    
        self.erType=CryptorCreationError;
        
        [self markAsFinished];
    }
}

-(void)checkSourceFile{

    BOOL sourceFileIsOk=YES;
    
    if([NSString isEmptyString:self.sourceFilePath]){
        
        self.erType=SourceFileNotExist;
        
        sourceFileIsOk=NO;
        
    }else{
    
        //if source file is dir or not exist,stop and return
        BOOL isDir=NO;
        BOOL isExistSourceFile=[self.fm fileExistsAtPath:self.sourceFilePath isDirectory:&isDir];
        if(isDir || !isExistSourceFile){
            
            if(isDir){
                
                self.erType=SourceFileIsDir;
                
            }else{
                
                self.erType=SourceFileNotExist;
            }
            
            sourceFileIsOk=NO;
            
        }else{
        
            //assignment source file size
            NSError *er=nil;
            NSDictionary *atd=[self.fm attributesOfItemAtPath:self.sourceFilePath error:&er];
            if(atd){
                
                self.fileSize=[atd fileSize];
                
            }else{
            
                self.erType=ReadFileError;
                sourceFileIsOk=NO;
            }
        }
    }
    
    if(!sourceFileIsOk){
    
        [self markAsFinished];
    }
}

-(void)checkAndCreateDestinationFile{

    //create des file path
    NSString *fName=[self.sourceFilePath lastPathComponent];
    if([NSString isEmptyString:fName]){
    
        fName=@"ffj";
        
    }else{
    
        fName=[NSString stringByTrimmingBothEndWhiteSpace:fName];
        if([NSString isEmptyString:fName] ||
           [fName isEqualToString:@"/"]){
        
            fName=@"ffj";
        }
    }
    
    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
    NSString *destinationFilePath= [paths firstObject];//目录结构：/Users/xx/.../Library/Caches
    
    NSLog(@"destinationFilePath:%@",destinationFilePath);
    
    destinationFilePath=[NSString stringWithFormat:@"%@/%@",destinationFilePath,fName];
    
    for(unsigned i=1; i<=10; i++) {
        
        if([self.fm fileExistsAtPath:destinationFilePath]) {
            
            srand(i);
            NSUInteger randNum=rand();
            
            destinationFilePath=[NSString stringWithFormat:@"%@ab%luc%@",destinationFilePath,(unsigned long)randNum,fName];
            
        }else{
        
            break;
        }
    }
    
    //copy des file path
    self.desFilePath=destinationFilePath;
    
    //delete and create des file
    [self.fm removeItemAtPath:destinationFilePath error:nil];
    
    BOOL ctStatus=[self.fm createFileAtPath:destinationFilePath contents:nil attributes:nil];
    
    if(!ctStatus){
        //create file occur error
        self.erType=CreatingFileError;
        
        [self markAsFinished];
    }
}

-(void)checkAndCreateFileStream{

    //create file stream
    self.readStream = [NSInputStream inputStreamWithFileAtPath:self.sourceFilePath];
    self.writeStream=[NSOutputStream outputStreamToFileAtPath:self.desFilePath append:YES];
    
    if(!self.readStream || !self.writeStream){
        
        self.erType=FileStreamError;
        
        [self markAsFinished];
        
    }else{
    
        //open stream
        [self.writeStream open];
        [self.readStream open];
    }
}

#pragma mark - Operation Status
-(void)setReadyStatus:(BOOL)status{
    
    ready=status;
}

-(void)setFinishedStatus:(BOOL)status{
    
    finished=status;
}

-(void)setExecutingStatus:(BOOL)status{

    executing=status;
}

-(void)setCancelledStatus:(BOOL)status{

    cancelled=status;
}

#pragma mark -
-(BOOL)isConcurrent{

    return YES;
}

-(BOOL)isAsynchronous{

    return YES;
}

//-(BOOL)isReady{
//
//    return ready;
//}

-(BOOL)isFinished{
    
    return finished;
}

-(BOOL)isExecuting{
    
    return executing;
}

- (BOOL)isCancelled{

    return cancelled;
}

#pragma mark - AES Encrypt/Decrypt logic
-(void)aesCBCCrypt{
    
    CCCryptorStatus result=kCCAlignmentError;
    /**
     @abstract    Calculate the buffer size and create the buffers.
     
     @discussion  The MAX() check isn't really necessary, but is a safety in
     since both buffers will be the same. This just guarentees the the read
     buffer will always be large enough, even during decryption.
     */
    size_t dstBufferSize = cryptReadSize;
    
    [self.oplock lock];
    if(![self isCancelled] && ![self isFinished] && _cryptor!=NULL){
    
        dstBufferSize=MAX(CCCryptorGetOutputLength(_cryptor, // cryptor
                                     cryptReadSize, // input length
                                     true), // final
            cryptReadSize);
    }else{
    
        [self.oplock unlock];
        return;
    }
    [self.oplock unlock];
    
    NSMutableData *dstData = [NSMutableData dataWithLength:dstBufferSize];
    NSMutableData *srcData = [NSMutableData dataWithLength:cryptReadSize];
    
    uint8_t *srcBytes = srcData.mutableBytes;
    uint8_t *dstBytes = dstData.mutableBytes;
    
    // Read and write the data in blocks
    ssize_t srcLength= 0;
    size_t dstLength = 0;
    
    BOOL hasMoreData=YES;
    while(hasMoreData){
        
        [self.oplock lock];
        if(![self isCancelled] && ![self isFinished] && self.readStream){
        
            srcLength=[self.readStream read:srcBytes maxLength:cryptReadSize];
            
        }else{
            
            [self.oplock unlock];
            
            return;
        }
        [self.oplock unlock];
        
        if(srcLength<0){
            
            if(![self isCancelled] && ![self isFinished]){
            
                self.erType=ReadFileError;
                
                [self markAsFinished];
            }
            
            return;
        }
        
        if(srcLength==0){
            break;
        }
        
        [self.oplock lock];
        if(![self isCancelled] && ![self isFinished] && _cryptor){
        
            result=CCCryptorUpdate(_cryptor,       // cryptor
                                   srcBytes,      // dataIn
                                   srcLength,     // dataInLength
                                   dstBytes,      // dataOut
                                   dstBufferSize, // dataOutAvailable
                                   &dstLength);   // dataOutMoved
        }else{
        
            [self.oplock unlock];
            return;
        }
        [self.oplock unlock];
        
        if(result != kCCSuccess || _cryptor == NULL){
            
            if(![self isCancelled] && ![self isFinished]){
                
                self.erType=CryptorUpdateError;
                
                [self markAsFinished];
            }
            
            return;
        }
        
        //write to file
        [self.oplock lock];
        NSInteger writedLength;
        if(![self isCancelled] && ![self isFinished] && self.writeStream){
        
            writedLength=[self.writeStream write:dstBytes maxLength:dstLength];
            
        }else{
        
            [self.oplock unlock];
            return;
        }
        [self.oplock unlock];
        
        if(writedLength<0){
            //writing occur error
            if(![self isCancelled] && ![self isFinished]){
                
                self.erType=WriteFileError;
                
                [self markAsFinished];
            }
            
            return;
        }
        
        //track progress
        self.xcryptSize+=srcLength;
        [self trackProgress];
    }
    
    //occur read file error.
    if(srcLength !=0){
        
        if(![self isCancelled] && ![self isFinished]){
            
            self.erType=ReadFileError;
            
            [self markAsFinished];
        }
        
        return;
    }
    
    [self.oplock lock];
    // Write the final block
    if(![self isCancelled] && ![self isFinished] && _cryptor!=NULL){
    
        result = CCCryptorFinal(_cryptor,        // cryptor
                                dstBytes,       // dataOut
                                dstBufferSize,  // dataOutAvailable
                                &dstLength);    // dataOutMoved
    }else{
    
        [self.oplock unlock];
        return;
    }
    [self.oplock unlock];
    
    //occur final block error.
    if(result != kCCSuccess || _cryptor == NULL){
        
        if(![self isCancelled] && ![self isFinished]){
            
            self.erType=CryptorFinalError;
            
            [self markAsFinished];
        }
        
        return;
    }
    
    //write to file
    [self.oplock lock];
    NSInteger writedLength;
    if(![self isCancelled] && ![self isFinished] && self.writeStream){
    
        writedLength=[self.writeStream write:dstBytes maxLength:dstLength];
    }else{
    
        [self.oplock unlock];
        return;
    }
    [self.oplock unlock];
    
    if(writedLength<0){
        //writing occur error
        if(![self isCancelled] && ![self isFinished]){
            
            self.erType=WriteFileError;
            
            [self markAsFinished];
        }
        
        return;
    }
    
    //finished Xcrypt
    if(![self isCancelled] && ![self isFinished]){
        
        [self finishedXcrypt];
    }
}

#pragma mark -
-(void)trackProgress{

    if(self.delegate &&
       [self.delegate respondsToSelector:@selector(xcryptRequest:progressRatioValue:)]){
    
        float ratio=(self.fileSize<=0) ? 0.0 : ((self.xcryptSize*1.0)/(self.fileSize*1.0));
        
        [self.delegate xcryptRequest:self progressRatioValue:ratio];
    }
    
    NSLog(@"%@",[NSThread currentThread]);
}

#pragma mark - Finished XCrypt
-(void)finishedXcrypt{

    [self willChangeValueForKey:@"isExecuting"];
    [self willChangeValueForKey:@"isFinished"];
    
    [self setFinishedStatus:YES];
    [self setExecutingStatus:NO];
    
    [self didChangeValueForKey:@"isExecuting"];
    [self didChangeValueForKey:@"isFinished"];
    
    [self succeededXcrypt];
}

-(void)markAsFinished{
    
    [self willChangeValueForKey:@"isExecuting"];
    [self willChangeValueForKey:@"isFinished"];
    
    [self setFinishedStatus:YES];
    [self setExecutingStatus:NO];
    
    [self didChangeValueForKey:@"isExecuting"];
    [self didChangeValueForKey:@"isFinished"];
    
    [self failedXcrypt];
}

#pragma mark -
-(void)succeededXcrypt{

    [self cleanup];
    
    //decrypt file,move and rename des file to sourcePath
    if(self.operation==kCCDecrypt){
        
        [self.fm removeItemAtPath:self.sourceFilePath error:nil];
        [self.fm moveItemAtPath:self.desFilePath toPath:self.sourceFilePath error:nil];
    }
    
    //noti delegate finished Xcrypt
    if(self.delegate &&
       [self.delegate respondsToSelector:@selector(succeededXCryptRequest:)]){
    
        [self.delegate succeededXCryptRequest:self];
    }
}

-(void)failedXcrypt{
    
    [self cleanup];
    
    [self collectionErrorInfo];
    
    //noti delegate failed Xcrypt
    if(self.delegate &&
       [self.delegate respondsToSelector:@selector(failedXCryptRequest:)]){
        
        [self.delegate failedXCryptRequest:self];
    }
}

-(void)collectionErrorInfo{

    self.er=[[NSError alloc] initWithDomain:XCryptRequestErrorDomain code:self.erType userInfo:nil];
}

-(void)unexceptionError:(NSError *)er{

    [self cleanup];
    
    self.er=er;
    
    //noti delegate failed Xcrypt
    if(self.delegate &&
       [self.delegate respondsToSelector:@selector(failedXCryptRequest:)]){
        
        [self.delegate failedXCryptRequest:self];
    }
}

#pragma mark - cleanup logic
-(void)cleanup{

    [self releaseCryptor];
    [self closeStream];
}

-(void)closeStream{

    [self.oplock lock];
    
    //close read stream
    if((self.readStream) &&
       (self.readStream.streamStatus!=NSStreamStatusClosed ||
        self.readStream.streamStatus!=NSStreamStatusNotOpen)){
           
           [self.readStream close];
       }
    
    //close write stream
    if((self.writeStream) &&
       (self.writeStream.streamStatus!=NSStreamStatusClosed ||
        self.writeStream.streamStatus!=NSStreamStatusNotOpen)){
           
           [self.writeStream close];
       }
    
    self.readStream=nil;
    self.writeStream=nil;
    
    [self.oplock unlock];
}

-(void)releaseCryptor{

    [self.oplock lock];
    //release cryptor
    if(_cryptor != NULL){
        
        CCCryptorRelease(_cryptor);
        
        _cryptor=NULL;
    }
    
    [self.oplock unlock];
}

#pragma mark - Delete File
-(void)deleteDestinationFile{

    //if is decrypt,then delete des file.
    if(![NSString isEmptyString:self.desFilePath] &&
       [self.fm fileExistsAtPath:self.desFilePath]){
        
        [self.fm removeItemAtPath:self.desFilePath error:nil];
    }
}

-(void)deleteSourceFile{

    if(![NSString isEmptyString:self.sourceFilePath] &&
       [self.fm fileExistsAtPath:self.sourceFilePath]){
        
        [self.fm removeItemAtPath:self.sourceFilePath error:nil];
    }
}

#pragma mark - Property
-(NSFileManager *)fm{

    if(!_fm){
    
        _fm=[NSFileManager defaultManager];
    }
    
    return _fm;
}

@end
